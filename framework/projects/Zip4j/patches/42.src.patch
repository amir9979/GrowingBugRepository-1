diff --git a/src/main/java/net/lingala/zip4j/crypto/AESEncrypter.java b/src/main/java/net/lingala/zip4j/crypto/AESEncrypter.java
index 9776ba8..9ef245e 100644
--- a/src/main/java/net/lingala/zip4j/crypto/AESEncrypter.java
+++ b/src/main/java/net/lingala/zip4j/crypto/AESEncrypter.java
@@ -23,10 +23,6 @@ import net.lingala.zip4j.model.enums.AesKeyStrength;
 
 import java.security.SecureRandom;
 
-import static net.lingala.zip4j.crypto.AesCipherUtil.derivePasswordBasedKey;
-import static net.lingala.zip4j.crypto.AesCipherUtil.derivePasswordVerifier;
-import static net.lingala.zip4j.crypto.AesCipherUtil.getAESEngine;
-import static net.lingala.zip4j.crypto.AesCipherUtil.getMacBasedPRF;
 import static net.lingala.zip4j.crypto.AesCipherUtil.prepareBuffAESIVBytes;
 import static net.lingala.zip4j.util.InternalZipConstants.AES_BLOCK_SIZE;
 
@@ -35,17 +31,19 @@ import static net.lingala.zip4j.util.InternalZipConstants.AES_BLOCK_SIZE;
  */
 public class AESEncrypter implements Encrypter {
 
+  private char[] password;
+  private AesKeyStrength aesKeyStrength;
   private AESEngine aesEngine;
   private MacBasedPRF mac;
-  private final SecureRandom random = new SecureRandom();
+  private SecureRandom random = new SecureRandom();
 
   private boolean finished;
 
   private int nonce = 1;
   private int loopCount = 0;
 
-  private final byte[] iv;
-  private final byte[] counterBlock;
+  private byte[] iv;
+  private byte[] counterBlock;
   private byte[] derivedPasswordVerifier;
   private byte[] saltBytes;
 
@@ -58,18 +56,20 @@ public class AESEncrypter implements Encrypter {
       throw new ZipException("Invalid AES key strength");
     }
 
+    this.password = password;
+    this.aesKeyStrength = aesKeyStrength;
     this.finished = false;
     counterBlock = new byte[AES_BLOCK_SIZE];
     iv = new byte[AES_BLOCK_SIZE];
-    init(password, aesKeyStrength);
+    init();
   }
 
-  private void init(char[] password, AesKeyStrength aesKeyStrength) throws ZipException {
+  private void init() throws ZipException {
     saltBytes = generateSalt(aesKeyStrength.getSaltLength());
-    byte[] derivedKey = derivePasswordBasedKey(saltBytes, password, aesKeyStrength);
-    derivedPasswordVerifier = derivePasswordVerifier(derivedKey, aesKeyStrength);
-    aesEngine = getAESEngine(derivedKey, aesKeyStrength);
-    mac = getMacBasedPRF(derivedKey, aesKeyStrength);
+    byte[] derivedKey = AesCipherUtil.derivePasswordBasedKey(saltBytes, password, aesKeyStrength);
+    derivedPasswordVerifier = AesCipherUtil.derivePasswordVerifier(derivedKey, aesKeyStrength);
+    aesEngine = AesCipherUtil.getAESEngine(derivedKey, aesKeyStrength);
+    mac = AesCipherUtil.getMacBasedPRF(derivedKey, aesKeyStrength);
   }
 
   public int encryptData(byte[] buff) throws ZipException {
@@ -116,18 +116,18 @@ public class AESEncrypter implements Encrypter {
       throw new ZipException("invalid salt size, cannot generate salt");
     }
 
-    int rounds;
+    int rounds = 0;
 
     if (size == 8) {
       rounds = 2;
-    } else {
+    } else if (size == 16) {
       rounds = 4;
     }
 
     byte[] salt = new byte[size];
     for (int j = 0; j < rounds; j++) {
       int i = random.nextInt();
-      salt[j * 4] = (byte) (i >> 24);
+      salt[0 + j * 4] = (byte) (i >> 24);
       salt[1 + j * 4] = (byte) (i >> 16);
       salt[2 + j * 4] = (byte) (i >> 8);
       salt[3 + j * 4] = (byte) i;
diff --git a/src/main/java/net/lingala/zip4j/crypto/StandardEncrypter.java b/src/main/java/net/lingala/zip4j/crypto/StandardEncrypter.java
index b179fa9..a6b14bf 100755
--- a/src/main/java/net/lingala/zip4j/crypto/StandardEncrypter.java
+++ b/src/main/java/net/lingala/zip4j/crypto/StandardEncrypter.java
@@ -25,10 +25,13 @@ import static net.lingala.zip4j.util.InternalZipConstants.STD_DEC_HDR_SIZE;
 
 public class StandardEncrypter implements Encrypter {
 
-  private final ZipCryptoEngine zipCryptoEngine = new ZipCryptoEngine();
+  private ZipCryptoEngine zipCryptoEngine;
   private byte[] headerBytes;
 
   public StandardEncrypter(char[] password, long key) throws ZipException {
+   this.zipCryptoEngine = new ZipCryptoEngine();
+
+    this.headerBytes = new byte[STD_DEC_HDR_SIZE];
     init(password, key);
   }
 
@@ -37,13 +40,17 @@ public class StandardEncrypter implements Encrypter {
       throw new ZipException("input password is null or empty, cannot initialize standard encrypter");
     }
     zipCryptoEngine.initKeys(password);
-    headerBytes = generateRandomBytes();
+    headerBytes = generateRandomBytes(STD_DEC_HDR_SIZE);
     // Initialize again since the generated bytes were encrypted.
     zipCryptoEngine.initKeys(password);
 
     headerBytes[STD_DEC_HDR_SIZE - 1] = (byte) ((key >>> 24));
     headerBytes[STD_DEC_HDR_SIZE - 2] = (byte) ((key >>> 16));
 
+    if (headerBytes.length < STD_DEC_HDR_SIZE) {
+      throw new ZipException("invalid header bytes generated, cannot perform standard encryption");
+    }
+
     encryptData(headerBytes);
   }
 
@@ -71,12 +78,17 @@ public class StandardEncrypter implements Encrypter {
     return temp_val;
   }
 
-  protected byte[] generateRandomBytes() {
-    byte[] buff = new byte[STD_DEC_HDR_SIZE];
+  protected byte[] generateRandomBytes(int size) throws ZipException {
+    if (size <= 0) {
+      throw new ZipException("size is either 0 or less than 0, cannot generate header for standard encryptor");
+    }
+
+    byte[] buff = new byte[size];
     SecureRandom random = new SecureRandom();
     for (int i = 0; i < buff.length; i++) {
       buff[i] = encryptByte((byte) random.nextInt(256));
     }
+
     return buff;
   }
 
diff --git a/src/main/java/net/lingala/zip4j/crypto/engine/ZipCryptoEngine.java b/src/main/java/net/lingala/zip4j/crypto/engine/ZipCryptoEngine.java
index a2d6b83..f52e80e 100755
--- a/src/main/java/net/lingala/zip4j/crypto/engine/ZipCryptoEngine.java
+++ b/src/main/java/net/lingala/zip4j/crypto/engine/ZipCryptoEngine.java
@@ -1,65 +1,62 @@
-/*
- * Copyright 2010 Srikanth Reddy Lingala
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package net.lingala.zip4j.crypto.engine;
-
-import static net.lingala.zip4j.util.Zip4jUtil.convertCharArrayToByteArray;
-
-public class ZipCryptoEngine {
-
-  private final int[] keys = new int[3];
-  private static final int[] CRC_TABLE = new int[256];
-
-  static {
-    for (int i = 0; i < 256; i++) {
-      int r = i;
-      for (int j = 0; j < 8; j++) {
-        if ((r & 1) == 1) {
-          r = (r >>> 1) ^ 0xedb88320;
-        } else {
-          r >>>= 1;
-        }
-      }
-      CRC_TABLE[i] = r;
-    }
-  }
-
-  public void initKeys(char[] password) {
-    keys[0] = 305419896;
-    keys[1] = 591751049;
-    keys[2] = 878082192;
-    byte[] bytes = convertCharArrayToByteArray(password);
-    for (byte b : bytes) {
-      updateKeys((byte) (b & 0xff));
-    }
-  }
-
-  public void updateKeys(byte charAt) {
-    keys[0] = crc32(keys[0], charAt);
-    keys[1] += keys[0] & 0xff;
-    keys[1] = keys[1] * 134775813 + 1;
-    keys[2] = crc32(keys[2], (byte) (keys[1] >> 24));
-  }
-
-  private int crc32(int oldCrc, byte charAt) {
-    return ((oldCrc >>> 8) ^ CRC_TABLE[(oldCrc ^ charAt) & 0xff]);
-  }
-
-  public byte decryptByte() {
-    int temp = keys[2] | 2;
-    return (byte) ((temp * (temp ^ 1)) >>> 8);
-  }
-}
+/*
+ * Copyright 2010 Srikanth Reddy Lingala
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.lingala.zip4j.crypto.engine;
+
+public class ZipCryptoEngine {
+
+  private final int keys[] = new int[3];
+  private static final int[] CRC_TABLE = new int[256];
+
+  static {
+    for (int i = 0; i < 256; i++) {
+      int r = i;
+      for (int j = 0; j < 8; j++) {
+        if ((r & 1) == 1) {
+          r = (r >>> 1) ^ 0xedb88320;
+        } else {
+          r >>>= 1;
+        }
+      }
+      CRC_TABLE[i] = r;
+    }
+  }
+
+  public void initKeys(char[] password) {
+    keys[0] = 305419896;
+    keys[1] = 591751049;
+    keys[2] = 878082192;
+    for (int i = 0; i < password.length; i++) {
+      updateKeys((byte) (password[i] & 0xff));
+    }
+  }
+
+  public void updateKeys(byte charAt) {
+    keys[0] = crc32(keys[0], charAt);
+    keys[1] += keys[0] & 0xff;
+    keys[1] = keys[1] * 134775813 + 1;
+    keys[2] = crc32(keys[2], (byte) (keys[1] >> 24));
+  }
+
+  private int crc32(int oldCrc, byte charAt) {
+    return ((oldCrc >>> 8) ^ CRC_TABLE[(oldCrc ^ charAt) & 0xff]);
+  }
+
+  public byte decryptByte() {
+    int temp = keys[2] | 2;
+    return (byte) ((temp * (temp ^ 1)) >>> 8);
+  }
+}
diff --git a/src/main/java/net/lingala/zip4j/util/Zip4jUtil.java b/src/main/java/net/lingala/zip4j/util/Zip4jUtil.java
index 0e77db2..1e49d1b 100755
--- a/src/main/java/net/lingala/zip4j/util/Zip4jUtil.java
+++ b/src/main/java/net/lingala/zip4j/util/Zip4jUtil.java
@@ -23,9 +23,6 @@ import net.lingala.zip4j.model.enums.CompressionMethod;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
-import java.nio.ByteBuffer;
-import java.nio.CharBuffer;
-import java.nio.charset.StandardCharsets;
 import java.util.Calendar;
 
 public class Zip4jUtil {
@@ -99,18 +96,11 @@ public class Zip4jUtil {
   }
 
   public static byte[] convertCharArrayToByteArray(char[] charArray) {
-    try {
-      ByteBuffer buf = StandardCharsets.UTF_8.encode(CharBuffer.wrap(charArray));
-      byte[] bytes = new byte[buf.limit()];
-      buf.get(bytes);
-      return bytes;
-    } catch (Exception e) {
-      byte[] bytes = new byte[charArray.length];
-      for (int i = 0; i < charArray.length; i++) {
-        bytes[i] = (byte) charArray[i];
-      }
-      return bytes;
+    byte[] bytes = new byte[charArray.length];
+    for (int i = 0; i < charArray.length; i++) {
+      bytes[i] = (byte) charArray[i];
     }
+    return bytes;
   }
 
   public static CompressionMethod getCompressionMethod(LocalFileHeader localFileHeader) {
