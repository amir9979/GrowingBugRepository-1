diff --git a/src/main/java/net/lingala/zip4j/tasks/AddStreamToZipTask.java b/src/main/java/net/lingala/zip4j/tasks/AddStreamToZipTask.java
index 61e6df2..406962d 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AddStreamToZipTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AddStreamToZipTask.java
@@ -1,7 +1,5 @@
 package net.lingala.zip4j.tasks;
 
-import net.lingala.zip4j.exception.ZipException;
-import net.lingala.zip4j.headers.HeaderUtil;
 import net.lingala.zip4j.headers.HeaderWriter;
 import net.lingala.zip4j.io.outputstream.SplitOutputStream;
 import net.lingala.zip4j.io.outputstream.ZipOutputStream;
@@ -30,8 +28,7 @@ public class AddStreamToZipTask extends AbstractAddFileToZipTask<AddStreamToZipT
 
     verifyZipParameters(taskParameters.zipParameters);
 
-    removeFileIfExists(getZipModel(), taskParameters.zipParameters.getFileNameInZip(), progressMonitor);
 
     // For streams, it is necessary to write extended local file header because of Zip standard encryption.
     // If we do not write extended local file header, zip standard encryption needs a crc upfront for key,
     // which cannot be calculated until we read the complete stream. If we use extended local file header,
@@ -72,17 +68,8 @@ public class AddStreamToZipTask extends AbstractAddFileToZipTask<AddStreamToZipT
     return 0;
   }
 
-  private void removeFileIfExists(ZipModel zipModel, String fileNameInZip, ProgressMonitor progressMonitor)
-      throws ZipException {
 
-    FileHeader fileHeader = HeaderUtil.getFileHeader(zipModel, fileNameInZip);
-    if (fileHeader  != null) {
-      RemoveEntryFromZipFileTask removeEntryFromZipFileTask = new RemoveEntryFromZipFileTask(progressMonitor, false,
-          zipModel);
-      removeEntryFromZipFileTask.execute(fileHeader);
-    }
-  }
 
   public static class AddStreamToZipTaskParameters {
     private InputStream inputStream;
     private ZipParameters zipParameters;
