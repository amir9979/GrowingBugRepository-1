diff --git a/src/main/java/com/spotify/sparkey/IndexHash.java b/src/main/java/com/spotify/sparkey/IndexHash.java
index 02a0693..c2ad9ff 100644
--- a/src/main/java/com/spotify/sparkey/IndexHash.java
+++ b/src/main/java/com/spotify/sparkey/IndexHash.java
@@ -61,6 +61,10 @@ final class IndexHash {
     entryBlockBitmask = ((1 << entryBlockBits) - 1);
 
     stream = new SafeStream(logData);
+    long expectedFileSize = IndexHeader.HEADER_SIZE + slotSize * hashCapacity;
+    if (expectedFileSize != indexFile.length()) {
+      throw new RuntimeException("Corrupt index file - incorrect size. Expected " + expectedFileSize + " but was " + indexFile.length());
+    }
   }
 
   static IndexHash open(File indexFile, File logFile) throws IOException {
diff --git a/src/main/java/com/spotify/sparkey/ReadOnlyMemMap.java b/src/main/java/com/spotify/sparkey/ReadOnlyMemMap.java
index 62e3eda..919ea60 100644
--- a/src/main/java/com/spotify/sparkey/ReadOnlyMemMap.java
+++ b/src/main/java/com/spotify/sparkey/ReadOnlyMemMap.java
@@ -41,7 +41,6 @@ final class ReadOnlyMemMap implements RandomAccessData {
 
   private static final long MAP_SIZE = 1 << 30;
   private static final long BITMASK_30 = ((1L << 30) - 1);
-  private final File file;
 
   private volatile MappedByteBuffer[] chunks;
   private final RandomAccessFile randomAccessFile;
@@ -52,12 +51,8 @@ final class ReadOnlyMemMap implements RandomAccessData {
   private volatile MappedByteBuffer curChunk;
 
   // Used for making sure we close all instances before cleaning up the byte buffers
-  private final List<ReadOnlyMemMap> allInstances;
 
   ReadOnlyMemMap(File file) throws IOException {
-    this.file = file;
-    this.allInstances = Lists.newArrayList();
-    this.allInstances.add(this);
 
     this.randomAccessFile = new RandomAccessFile(file, "r");
     this.size = file.length();
@@ -87,75 +82,55 @@ final class ReadOnlyMemMap implements RandomAccessData {
     curChunk.position(0);
   }
 
-  private ReadOnlyMemMap(ReadOnlyMemMap source, MappedByteBuffer[] chunks) {
-    this.file = source.file;
-    this.allInstances = source.allInstances;
-    this.randomAccessFile = source.randomAccessFile;
-    this.size = source.size;
-    this.numChunks = source.numChunks;
-    this.chunks = chunks;
+  private ReadOnlyMemMap(ReadOnlyMemMap largeMemMap) {
+    this.randomAccessFile = largeMemMap.randomAccessFile;
+    this.size = largeMemMap.size;
+    this.numChunks = largeMemMap.numChunks;
+    this.chunks = new MappedByteBuffer[numChunks];
+    for (int i = 0; i < numChunks; i++) {
+      chunks[i] = (MappedByteBuffer) largeMemMap.chunks[i].duplicate();
+    }
     curChunkIndex = 0;
     curChunk = chunks[0];
     curChunk.position(0);
   }
 
   public void close() {
-    final MappedByteBuffer[] chunks;
-    synchronized (allInstances) {
-      if (this.chunks == null) {
-        return;
-      }
-      chunks = this.chunks;
-      for (ReadOnlyMemMap map : allInstances) {
-        map.chunks = null;
-        map.curChunk = null;
-        try {
-          map.randomAccessFile.close();
-        } catch (IOException e) {
-          e.printStackTrace(System.err);
-        }
-      }
+    for (int i = 0; i < numChunks; i++) {
+      chunks[i] = null;
     }
     // Wait a bit with closing so that all threads have a chance to see the that
     // chunks and curChunks are null
-    CLEANER.schedule(new Runnable() {
-      @Override
-      public void run() {
-        for (MappedByteBuffer chunk : chunks) {
-          ByteBufferCleaner.cleanMapping(chunk);
-        }
-      }
-    }, 1000, TimeUnit.MILLISECONDS);
+    curChunk = null;
+    try {
+      randomAccessFile.close();
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
   }
 
   public void seek(long pos) throws IOException {
     if (pos > size) {
-      throw corruptionException();
+      throw new IOException("Corrupt index: referencing data outside of range");
     }
     int partIndex = (int) (pos >>> 30);
     curChunkIndex = partIndex;
-    MappedByteBuffer[] chunks = getChunks();
-    MappedByteBuffer curChunk = chunks[partIndex];
+    curChunk = chunks[partIndex];
     curChunk.position((int) (pos & BITMASK_30));
     this.curChunk = curChunk;
   }
 
   private void next() throws IOException {
-    MappedByteBuffer[] chunks = getChunks();
     curChunkIndex++;
     if (curChunkIndex >= chunks.length) {
-      throw corruptionException();
-    }
-    MappedByteBuffer curChunk = chunks[curChunkIndex];
-    if (curChunk != null) {
-      curChunk.position(0);
-      this.curChunk = curChunk;
+      throw new IOException("Corrupt index: referencing data outside of range");
     }
+    curChunk = chunks[curChunkIndex];
+    curChunk.position(0);
   }
 
   @Override
   public int readUnsignedByte() throws IOException {
-    MappedByteBuffer curChunk = getCurChunk();
     if (curChunk.remaining() == 0) {
       next();
     }
@@ -163,7 +138,6 @@ final class ReadOnlyMemMap implements RandomAccessData {
   }
 
   public void readFully(byte[] buffer, int offset, int length) throws IOException {
-    MappedByteBuffer curChunk = getCurChunk();
     long remaining = curChunk.remaining();
     if (remaining >= length) {
       curChunk.get(buffer, offset, length);
@@ -178,7 +152,6 @@ final class ReadOnlyMemMap implements RandomAccessData {
   }
 
   public void skipBytes(long amount) throws IOException {
-    MappedByteBuffer curChunk = getCurChunk();
     int remaining = curChunk.remaining();
     if (remaining >= amount) {
       curChunk.position((int) (curChunk.position() + amount));
@@ -188,44 +161,13 @@ final class ReadOnlyMemMap implements RandomAccessData {
     }
   }
 
-  private MappedByteBuffer[] getChunks() throws SparkeyReaderClosedException {
-    MappedByteBuffer[] localChunks = chunks;
-    if (localChunks == null) {
-      throw closedException();
-    }
-    return localChunks;
-  }
 
-  private MappedByteBuffer getCurChunk() throws SparkeyReaderClosedException {
-    MappedByteBuffer curChunk = this.curChunk;
-    if (curChunk == null) {
-      throw closedException();
-    }
-    return curChunk;
-  }
 
-  private IOException corruptionException() {
-    return new CorruptedIndexException("Index is likely corrupt (" + file.getPath() + "), referencing data outside of range");
-  }
 
-  private SparkeyReaderClosedException closedException() {
-    return new SparkeyReaderClosedException("Reader has been closed");
-  }
 
   public ReadOnlyMemMap duplicate() {
-    synchronized (allInstances) {
-      if (chunks == null) {
         // Duplicating a closed instance is silly, and there's no point in actually duplicating it
-        return this;
-      }
-      MappedByteBuffer[] chunks = new MappedByteBuffer[numChunks];
-      for (int i = 0; i < numChunks; i++) {
-        chunks[i] = (MappedByteBuffer) this.chunks[i].duplicate();
-      }
-      ReadOnlyMemMap duplicate = new ReadOnlyMemMap(this, chunks);
-      allInstances.add(duplicate);
-      return duplicate;
-    }
+    return new ReadOnlyMemMap(this);
   }
 
   @Override
